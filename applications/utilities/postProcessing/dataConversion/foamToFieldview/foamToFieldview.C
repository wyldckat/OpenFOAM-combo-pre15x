/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright (C) 1991-2005 OpenCFD Ltd.
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM; if not, write to the Free Software Foundation,
    Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

Description
    Write out the FOAM mesh in Fieldview-UNS format (binary).
    See Fieldview Release 8 Reference Manual - Appendix D
    (Unstructured Data Format)
    Borrows various from uns/write_binary_uns.c from FieldView dist.

\*---------------------------------------------------------------------------*/

#include "argList.H"
#include "GeometricField.H"
#include "pointFields.H"
#include "volPointInterpolation.H"
#include "wallFvPatch.H"
#include "symmetryFvPatch.H"

#include "Cloud.H"
#include "passiveParticle.H"

#include "IOobjectList.H"
#include "boolList.H"
#include "stringList.H"
#include "DynamicList.H"
#include "cellModeller.H"

#include "floatScalar.H"
#include "calcFaceAddressing.H"
#include "writeFunctions.H"

#include <fstream>

#include "fv_reader_tags.h"

extern "C"
{
    unsigned int fv_encode_elem_header(int elem_type, int wall_info[]);
}

using namespace Foam;

typedef Field<floatScalar> floatField;


static HashTable<word> FieldviewNames;


static word getFieldViewName(const word& foamName)
{
    if (FieldviewNames.found(foamName))
    {
        return FieldviewNames[foamName];
    }
    else
    {
        return foamName;
    }
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
// Main program:

int main(int argc, char *argv[])
{
    argList::noParallel();
    argList::validOptions.insert("time", "time");
    argList::validOptions.insert("noWall", "");

#   include "setRootCase.H"

#   include "createTime.H"
#   include "createMesh.H"

    // Mark all faces that are to be seen as wall for particle
    // tracking and all cells that use one or more of these walls

    labelList wallFace(mesh.nFaces(), NOT_A_WALL);
    boolList wallCell(mesh.nCells(), false);

    if (!args.options().found("noWall"))
    {
        forAll (mesh.boundary(), patchI)
        {
            const fvPatch& currPatch = mesh.boundary()[patchI];
            if 
            (
                (typeid(currPatch) == typeid(wallFvPatch))
             || (typeid(currPatch) == typeid(symmetryFvPatch))
            )
            {
                const polyPatch& patch = currPatch.patch();
                const labelList::subList faceCells = patch.faceCells();

                forAll(faceCells, faceI)
                {
                    wallFace[patch.start() + faceI] = A_WALL;
                    wallCell[faceCells[faceI]] = true;
                }
            }
        }
    }


    // Make topology arrays in Fieldview format

    const cellModel& tet = *(cellModeller::lookup("tet"));
    const cellModel& pyr = *(cellModeller::lookup("pyr"));
    const cellModel& prism = *(cellModeller::lookup("prism"));
    const cellModel& wedge = *(cellModeller::lookup("wedge"));
    const cellModel& tetWedge = *(cellModeller::lookup("tetWedge"));
    const cellModel& hex = *(cellModeller::lookup("hex"));

    const pointField& points = mesh.points();
    const cellList& cellFaces = mesh.cells();
    const faceList& faces = mesh.faces();
    const cellShapeList& cellShapes = mesh.cellShapes();
    const labelList& owner = mesh.faceOwner();


    // Storage for header(1 int) + vertex labels(1 int per vertex)
    labelList hexLabels(cellFaces.size()*(1+8), 0);
    labelList prismLabels(cellFaces.size()*(1+6), 0);

    // Dynamic lists for pyramids and tets because they are also generated by
    // the splitting of complex cells.
    DynamicList<label> pyrLabels;
    DynamicList<label> tetLabels;

    // Count elements
    label nTet = 0;
    label nPyr = 0;
    label nPrism = 0;
    label nHex = 0;

    label nPoints = points.size();
    label nCentreVertices = 0;

    label hexi = 0;
    label prismi = 0;
    label pyri = 0;
    label teti = 0;

    labelList centreVertices(cellFaces.size());
    labelList notWallFlags(6, NOT_A_WALL);
    labelList wallFlags(6);

    // Pre calculate headers for cells not on walls
    label tetNotWall = fv_encode_elem_header
    (
        FV_TET_ELEM_ID, notWallFlags.begin()
    );
    label pyrNotWall = fv_encode_elem_header
    (
        FV_PYRA_ELEM_ID, notWallFlags.begin()
    );
    label prismNotWall = fv_encode_elem_header
    (
        FV_PRISM_ELEM_ID, notWallFlags.begin()
    );
    label hexNotWall = fv_encode_elem_header
    (
        FV_HEX_ELEM_ID, notWallFlags.begin()
    );


    const faceList& allFaces = mesh.faces();

    forAll(cellShapes, celli)
    {
        const cellShape& cellShape = cellShapes[celli];
        const cellModel& cellModel = cellShape.model();

        if (cellModel == tet)
        {
            nTet++;

            if (!wallCell[celli])
            {
                tetLabels(teti++) = tetNotWall;
            }
            else
            {
                labelList modelToMesh = calcFaceAddressing
                (
                    allFaces, cellShape, cellFaces[celli], celli
                );

                wallFlags[0] = wallFace[modelToMesh[0]];
                wallFlags[1] = wallFace[modelToMesh[1]];
                wallFlags[2] = wallFace[modelToMesh[2]];
                wallFlags[3] = wallFace[modelToMesh[3]];

                tetLabels(teti++) = fv_encode_elem_header
                (
                    FV_TET_ELEM_ID, wallFlags.begin()
                );
            }

            tetLabels(teti++) = cellShape[0] + 1;
            tetLabels(teti++) = cellShape[1] + 1;
            tetLabels(teti++) = cellShape[2] + 1;
            tetLabels(teti++) = cellShape[3] + 1;
        }
        else if (cellModel == pyr)
        {
            nPyr++;

            if (!wallCell[celli])
            {
                pyrLabels(pyri++) = pyrNotWall;
            }
            else
            {
                labelList modelToMesh = calcFaceAddressing
                (
                    allFaces, cellShape, cellFaces[celli], celli
                );

                wallFlags[0] = wallFace[modelToMesh[0]];
                wallFlags[1] = wallFace[modelToMesh[3]];
                wallFlags[2] = wallFace[modelToMesh[2]];
                wallFlags[3] = wallFace[modelToMesh[1]];
                wallFlags[4] = wallFace[modelToMesh[4]];

                pyrLabels(pyri++) = fv_encode_elem_header
                (
                    FV_PYRA_ELEM_ID, wallFlags.begin()
                );
            }

            pyrLabels(pyri++) = cellShape[0] + 1;
            pyrLabels(pyri++) = cellShape[1] + 1;
            pyrLabels(pyri++) = cellShape[2] + 1;
            pyrLabels(pyri++) = cellShape[3] + 1;
            pyrLabels(pyri++) = cellShape[4] + 1;
        }
        else if (cellModel == prism)
        {
            nPrism++;

            if (!wallCell[celli])
            {
                prismLabels[prismi++] = prismNotWall;
            }
            else
            {
                labelList modelToMesh = calcFaceAddressing
                (
                    allFaces, cellShape, cellFaces[celli], celli
                );

                wallFlags[0] = wallFace[modelToMesh[4]];
                wallFlags[1] = wallFace[modelToMesh[2]];
                wallFlags[2] = wallFace[modelToMesh[3]];
                wallFlags[3] = wallFace[modelToMesh[0]];
                wallFlags[4] = wallFace[modelToMesh[1]];

                prismLabels[prismi++] = fv_encode_elem_header
                (
                    FV_PRISM_ELEM_ID, wallFlags.begin()
                );
            }

            prismLabels[prismi++] = cellShape[0] + 1;
            prismLabels[prismi++] = cellShape[3] + 1;
            prismLabels[prismi++] = cellShape[4] + 1;
            prismLabels[prismi++] = cellShape[1] + 1;
            prismLabels[prismi++] = cellShape[5] + 1;
            prismLabels[prismi++] = cellShape[2] + 1;
        }
        else if (cellModel == tetWedge)
        {
            // Treat as prism with collapsed edge
            nPrism++;

            if (!wallCell[celli])
            {
                prismLabels[prismi++] = prismNotWall;
            }
            else
            {
                labelList modelToMesh = calcFaceAddressing
                (
                    allFaces, cellShape, cellFaces[celli], celli
                );

                wallFlags[0] = wallFace[modelToMesh[1]];
                wallFlags[1] = wallFace[modelToMesh[2]];
                wallFlags[2] = wallFace[modelToMesh[3]];
                wallFlags[3] = wallFace[modelToMesh[0]];
                wallFlags[4] = wallFace[modelToMesh[3]];

                prismLabels[prismi++] = fv_encode_elem_header
                (
                    FV_PRISM_ELEM_ID, wallFlags.begin()
                );
            }

            prismLabels[prismi++] = cellShape[0] + 1;
            prismLabels[prismi++] = cellShape[3] + 1;
            prismLabels[prismi++] = cellShape[4] + 1;
            prismLabels[prismi++] = cellShape[1] + 1;
            prismLabels[prismi++] = cellShape[4] + 1;
            prismLabels[prismi++] = cellShape[2] + 1;
        }
        else if (cellModel == wedge)
        {
            nHex++;

            if (!wallCell[celli])
            {
                hexLabels[hexi++] = hexNotWall;
            }
            else
            {
                labelList modelToMesh = calcFaceAddressing
                (
                    allFaces, cellShape, cellFaces[celli], celli
                );

                wallFlags[0] = wallFace[modelToMesh[2]];
                wallFlags[1] = wallFace[modelToMesh[3]];
                wallFlags[2] = wallFace[modelToMesh[0]];
                wallFlags[3] = wallFace[modelToMesh[1]];
                wallFlags[4] = wallFace[modelToMesh[4]];
                wallFlags[5] = wallFace[modelToMesh[5]];

                hexLabels[hexi++] = fv_encode_elem_header
                (
                    FV_HEX_ELEM_ID, wallFlags.begin()
                );
            }
            hexLabels[hexi++] = cellShape[0] + 1;
            hexLabels[hexi++] = cellShape[1] + 1;
            hexLabels[hexi++] = cellShape[0] + 1;
            hexLabels[hexi++] = cellShape[2] + 1;
            hexLabels[hexi++] = cellShape[3] + 1;
            hexLabels[hexi++] = cellShape[4] + 1;
            hexLabels[hexi++] = cellShape[6] + 1;
            hexLabels[hexi++] = cellShape[5] + 1;
        }
        else if (cellModel == hex)
        {
            nHex++;

            if (!wallCell[celli])
            {
                hexLabels[hexi++] = hexNotWall;
            }
            else
            {
                labelList modelToMesh = calcFaceAddressing
                (
                    allFaces, cellShape, cellFaces[celli], celli
                );

                wallFlags[0] = wallFace[modelToMesh[0]];
                wallFlags[1] = wallFace[modelToMesh[1]];
                wallFlags[2] = wallFace[modelToMesh[4]];
                wallFlags[3] = wallFace[modelToMesh[5]];
                wallFlags[4] = wallFace[modelToMesh[2]];
                wallFlags[5] = wallFace[modelToMesh[3]];

                hexLabels[hexi++] = fv_encode_elem_header
                (
                    FV_HEX_ELEM_ID, wallFlags.begin()
                );
            }
            hexLabels[hexi++] = cellShape[0] + 1;
            hexLabels[hexi++] = cellShape[1] + 1;
            hexLabels[hexi++] = cellShape[3] + 1;
            hexLabels[hexi++] = cellShape[2] + 1;
            hexLabels[hexi++] = cellShape[4] + 1;
            hexLabels[hexi++] = cellShape[5] + 1;
            hexLabels[hexi++] = cellShape[7] + 1;
            hexLabels[hexi++] = cellShape[6] + 1;
        }
        else
        {
            forAll(cellFaces[celli], facei)
            {
                const face& f = faces[cellFaces[celli][facei]];

                // Indices into storage
                label nQuads = 0;
                label nTris = 0;

                // Storage for triangles and quads created by face
                // decomposition (sized for worst case)
                faceList quadFaces((f.size() - 2)/2);
                faceList triFaces(f.size() - 2);

                f.trianglesQuads
                (
                    points,
                    nTris,
                    nQuads,
                    triFaces,
                    quadFaces
                );

                for (label i=0; i<nTris; i++)
                {
                    nTet++;

                    if (wallFace[cellFaces[celli][facei]] == NOT_A_WALL)
                    {
                        tetLabels(teti++) = tetNotWall;
                    }
                    else
                    {
                        wallFlags = NOT_A_WALL;
                        wallFlags[0] = A_WALL;

                        tetLabels(teti++) = fv_encode_elem_header
                        (
                            FV_TET_ELEM_ID, wallFlags.begin()
                        );
                    }

                    if (celli == owner[cellFaces[celli][facei]])
                    {
                        tetLabels(teti++) = triFaces[i][0] + 1;
                        tetLabels(teti++) = triFaces[i][1] + 1;
                        tetLabels(teti++) = triFaces[i][2] + 1;
                    }
                    else
                    {
                        tetLabels(teti++) = triFaces[i][2] + 1;
                        tetLabels(teti++) = triFaces[i][1] + 1;
                        tetLabels(teti++) = triFaces[i][0] + 1;
                    }

                    tetLabels(teti++) = nPoints + nCentreVertices + 1;
                }

                for (label i=0; i<nQuads; i++)
                {
                    nPyr++;

                    if (wallFace[cellFaces[celli][facei]] == NOT_A_WALL)
                    {
                        pyrLabels(pyri++) = pyrNotWall;
                    }
                    else
                    {
                        wallFlags = NOT_A_WALL;
                        wallFlags[0] = A_WALL;

                        pyrLabels(pyri++) = fv_encode_elem_header
                        (
                            FV_PYRA_ELEM_ID, wallFlags.begin()
                        );
                    }

                    if (celli == owner[cellFaces[celli][facei]])
                    {
                        pyrLabels(pyri++) = quadFaces[i][3] + 1;
                        pyrLabels(pyri++) = quadFaces[i][2] + 1;
                        pyrLabels(pyri++) = quadFaces[i][1] + 1;
                        pyrLabels(pyri++) = quadFaces[i][0] + 1;
                    }
                    else
                    {
                        pyrLabels(pyri++) = quadFaces[i][0] + 1;
                        pyrLabels(pyri++) = quadFaces[i][1] + 1;
                        pyrLabels(pyri++) = quadFaces[i][2] + 1;
                        pyrLabels(pyri++) = quadFaces[i][3] + 1;
                    }

                    pyrLabels(pyri++) = nPoints + nCentreVertices + 1;
                }
            }

            centreVertices[nCentreVertices] = celli;
            nCentreVertices++;
        }
    }



    instantList Times = runTime.times();


    // Initialize name mapping table
    FieldviewNames.insert("alpha", "aalpha");
    FieldviewNames.insert("Alpha", "AAlpha");
    FieldviewNames.insert("fsmach", "ffsmach");
    FieldviewNames.insert("FSMach", "FFSMach");
    FieldviewNames.insert("re", "rre");
    FieldviewNames.insert("Re", "RRe");
    FieldviewNames.insert("time", "ttime");
    FieldviewNames.insert("Time", "TTime");
    FieldviewNames.insert("pi", "ppi");
    FieldviewNames.insert("PI", "PPI");
    FieldviewNames.insert("x", "xx");
    FieldviewNames.insert("X", "XX");
    FieldviewNames.insert("y", "yy");
    FieldviewNames.insert("Y", "YY");
    FieldviewNames.insert("z", "zz");
    FieldviewNames.insert("Z", "ZZ");
    FieldviewNames.insert("rcyl", "rrcyl");
    FieldviewNames.insert("Rcyl", "RRcyl");
    FieldviewNames.insert("theta", "ttheta");
    FieldviewNames.insert("Theta", "TTheta");
    FieldviewNames.insert("rsphere", "rrsphere");
    FieldviewNames.insert("Rsphere", "RRsphere");
    FieldviewNames.insert("k", "kk");
    FieldviewNames.insert("K", "KK");


    // Scan for all available fields, in all timesteps
    //     volScalarNames  : all scalar fields
    //     volVectorNames  : ,,  vector ,,
    //     surfScalarNames : surface fields
    //     surfVectorNames : ,,
    //     sprayScalarNames: spray fields
    //     sprayVectorNames: ,,
#   include "getFieldNames.H"

    bool hasLagrangian = false;
    if ((sprayScalarNames.size() > 0) || (sprayVectorNames.size() > 0))
    {
        hasLagrangian = true;
    }

    Info<< "All fields:   Foam/Fieldview" << endl;
    Info<< "    volScalar   :";
    forAll(volScalarNames, fieldI)
    {
        Info<< " " << volScalarNames[fieldI] << '/'
            << getFieldViewName(volScalarNames[fieldI]);
    }
    Info<< endl;
    Info<< "    volVector   :";
    forAll(volVectorNames, fieldI)
    {
        Info<< " " << volVectorNames[fieldI] << '/'
            << getFieldViewName(volVectorNames[fieldI]);
    }
    Info<< endl;
    Info<< "    surfScalar  :";
    forAll(surfScalarNames, fieldI)
    {
        Info<< " " << surfScalarNames[fieldI] << '/'
            << getFieldViewName(surfScalarNames[fieldI]);
    }
    Info<< endl;
    Info<< "    surfVector  :";
    forAll(surfVectorNames, fieldI)
    {
        Info<< " " << surfVectorNames[fieldI] << '/'
            << getFieldViewName(surfVectorNames[fieldI]);
    }
    Info<< endl;
    Info<< "    sprayScalar :";
    forAll(sprayScalarNames, fieldI)
    {
        Info<< " " << sprayScalarNames[fieldI] << '/'
            << getFieldViewName(sprayScalarNames[fieldI]);
    }
    Info<< endl;
    Info<< "    sprayVector :";
    forAll(sprayVectorNames, fieldI)
    {
        Info<< " " << sprayVectorNames[fieldI] << '/'
            << getFieldViewName(sprayVectorNames[fieldI]);
    }
    Info<< endl;


    //
    // Start writing
    //

    // make a directory called FieldView in the case
    fileName fvPath(runTime.path()/"Fieldview");

    if (dir(fvPath))
    {
        rmDir(fvPath);
    }

    mkDir(fvPath);

    fileName fvParticleFileName(fvPath/runTime.caseName() + ".fvp");
    if (hasLagrangian)
    {
        Info<< "Opening particle file " << fvParticleFileName << endl;
    }
    std::ofstream fvParticleFile(fvParticleFileName.c_str());

    // Write spray file header
    if (hasLagrangian)
    {
#       include "writeSprayHeader.H"
    }


    label startTime = 0;
    label endTime = 0;
    label fieldViewTime = 0;

    // set startTime and endTime depending on -time option present
#   include "checkTimeOption.H"

    for (label i = startTime; i < endTime; i++)
    {
        runTime.setTime(Times[i], i);

        //
        // Check if new points (so moving mesh)
        //
#       include "moveMesh.H"


        //
        // Create file and write header
        //

        fileName fvFileName
        (
            fvPath/runTime.caseName() + "_" + Foam::name(i) + ".uns"
        );

        Info<< "Time " << Times[i].name() << endl;

        Info<< "    file:" << fvFileName.c_str() << endl;


        std::ofstream fvFile(fvFileName.c_str());


        // Output the magic number.
        writeInt(fvFile, FV_MAGIC);
        
        // Output file header and version number.
        writeStr80(fvFile, "FIELDVIEW");

        // This version of the FIELDVIEW unstructured file is "2.5".
        // This is written as two integers.
        writeInt(fvFile, 2);
        writeInt(fvFile, 5);


        // Output constants for time, fsmach, alpha and re.
        float fBuf[4];  // float bufffer
        fBuf[0] = Times[i].value();
        fBuf[1] = 0.0;
        fBuf[2] = 0.0;
        fBuf[3] = 1.0;
        fvFile.write((char *)fBuf, 4*sizeof(float));


        // Output the number of grids
        writeInt(fvFile, 1);


        //
        //  Boundary table
        //

        // num patches
        writeInt(fvFile, mesh.boundary().size());

        forAll (mesh.boundary(), patchI)
        {
            const fvPatch& currPatch = mesh.boundary()[patchI];

            writeInt(fvFile, 1);   // data present
            writeInt(fvFile, 1);   // normals ok

            // name
            writeStr80(fvFile, currPatch.name().c_str());
        }


        //
        // Create fields:
        //     volFieldPtrs     : List of ptrs to all volScalar/Vector fields
        //                        (null if field not present at current time)
        //     volFieldNames    : FieldView compatible names of volFields
        //     surfFieldPtrs    : same for surfaceScalar/Vector
        //     surfFieldNames
#       include "createFields.H"



        //
        // Write Variables table
        //


        writeInt(fvFile, volFieldNames.size());
        forAll(volFieldNames, fieldI)
        {
            if (volFieldPtrs[fieldI] == NULL)
            {
                Info<< "    dummy field for "   
                    << volFieldNames[fieldI].c_str() << endl;
            }

            writeStr80(fvFile, volFieldNames[fieldI].c_str());
        }

        //
        // Write Boundary Variables table = vol + surface fields
        //

        writeInt
        (
            fvFile,
            volFieldNames.size() + surfFieldNames.size()
        );
        forAll(volFieldNames, fieldI)
        {
            writeStr80(fvFile, volFieldNames[fieldI].c_str());
        }
        forAll(surfFieldNames, fieldI)
        {
            if (surfFieldPtrs[fieldI] == NULL)
            {
                Info<< "    dummy surface field for "
                    << surfFieldNames[fieldI].c_str() << endl;
            }

            writeStr80(fvFile, surfFieldNames[fieldI].c_str());
        }


        // Output grid data.

        //
        // Nodes
        //
        const volVectorField& centres = mesh.C();

        writeInt(fvFile, FV_NODES);
        writeInt(fvFile, nPoints + nCentreVertices);

        for (direction cmpt=0; cmpt<vector::nComponents; cmpt++)
        {
            floatField fField(nPoints + nCentreVertices);

            for (label pointi = 0; pointi<nPoints; pointi++)
            {
                fField[pointi] = float(points[pointi][cmpt]);
            }

            for (label pointi = 0; pointi<nCentreVertices; pointi++)
            {
                fField[nPoints + pointi] =
                    float(centres[centreVertices[pointi]][cmpt]);
            }

            fvFile.write((char *)fField.begin(), fField.size()*sizeof(float));
        }

        //
        // Boundary Faces
        //

        List<DynamicList<label> > patchFaceMap(mesh.boundaryMesh().size());

        forAll(mesh.boundary(), patchI)
        {
            const unallocFaceList& patchFaces = mesh.boundaryMesh()[patchI];
            DynamicList<label>& faceMap = patchFaceMap[patchI];
            faceMap.setSize(patchFaces.size());

            // Faces, each 4 labels
            DynamicList<label> faceLabels(patchFaces.size()*4);

            label nFaces = 0;
            label labelI = 0;

            forAll(patchFaces, faceI)
            {
                const face& patchFace = patchFaces[faceI];

                if (patchFace.size() == 3)
                {
                    faceMap(nFaces) = faceI;
                    nFaces++;

                    faceLabels(labelI++) = patchFace[0] + 1;
                    faceLabels(labelI++) = patchFace[1] + 1;
                    faceLabels(labelI++) = patchFace[2] + 1;
                    faceLabels(labelI++) = 0;   // Fieldview:triangle definition
                }
                else if (patchFace.size() == 4)
                {
                    faceMap(nFaces) = faceI;
                    nFaces++;

                    faceLabels(labelI++) = patchFace[0] + 1;
                    faceLabels(labelI++) = patchFace[1] + 1;
                    faceLabels(labelI++) = patchFace[2] + 1;
                    faceLabels(labelI++) = patchFace[3] + 1;
                } 
                else
                {
                    // Indices into storage
                    label nQuads = 0;
                    label nTris = 0;

                    // Storage for triangles and quads created by face
                    // decomposition. Sized for worst case.
                    faceList quadFaces((patchFace.size() - 2)/2);
                    faceList triFaces(patchFace.size() - 2);

                    patchFace.trianglesQuads
                    (
                        points,
                        nTris,
                        nQuads,
                        triFaces,
                        quadFaces
                    );

                    for (label i=0; i<nTris; i++)
                    {
                        faceMap(nFaces) = faceI;
                        nFaces++;

                        faceLabels(labelI++) = triFaces[i][0] + 1;
                        faceLabels(labelI++) = triFaces[i][1] + 1;
                        faceLabels(labelI++) = triFaces[i][2] + 1;
                        faceLabels(labelI++) = 0;
                    }

                    for (label i=0; i<nQuads; i++)
                    {
                        faceMap(nFaces) = faceI;
                        nFaces++;

                        faceLabels(labelI++) = quadFaces[i][3] + 1;
                        faceLabels(labelI++) = quadFaces[i][2] + 1;
                        faceLabels(labelI++) = quadFaces[i][1] + 1;
                        faceLabels(labelI++) = quadFaces[i][0] + 1;
                    }
                }
            }
            
            writeInt(fvFile, FV_FACES);
            writeInt(fvFile, patchI + 1);  // patch number
            writeInt(fvFile, nFaces);      // number of faces in patch
            fvFile.write
            (
                (char *)faceLabels.begin(), nFaces*4*sizeof(int)
            );
        }


        // Write topology
        writeInt(fvFile, FV_ELEMENTS);
        writeInt(fvFile, nTet);
        writeInt(fvFile, nHex);
        writeInt(fvFile, nPrism);
        writeInt(fvFile, nPyr);
	    fvFile.write((char *)tetLabels.begin(), nTet*(1+4)*sizeof(int));
        fvFile.write((char *)hexLabels.begin(), nHex*(1+8)*sizeof(int));
        fvFile.write((char *)prismLabels.begin(), nPrism*(1+6)*sizeof(int));
        fvFile.write((char *)pyrLabels.begin(), nPyr*(1+5)*sizeof(int));


        //
        // Variables data
        //

        pointMesh pMesh(mesh);
        volPointInterpolation pInterp(mesh, pMesh);

        writeInt(fvFile, FV_VARIABLES);

        // Create dummy field
        floatField dummyField(nPoints + nCentreVertices, 0.0);

        forAll(volFieldPtrs, fieldI)
        {
            if (volFieldPtrs[fieldI] != NULL)
            {
                const volScalarField& vField = *volFieldPtrs[fieldI];

                // Interpolate to points
                pointScalarField psf(pInterp.interpolate(vField));

                floatField fField(nPoints + nCentreVertices);

                for (label pointi = 0; pointi<nPoints; pointi++)
                {
                    fField[pointi] = float(psf[pointi]);
                }

                /*
                for (label pointi = 0; pointi<nCentreVertices; pointi++)
                {
                    fField[nPoints + pointi] =
                        float(vField[centreVertices[pointi]]);
                }
                */

                for (label pointi = 0; pointi<nCentreVertices; pointi++)
                {
                    labelList ps =
                        cellFaces[centreVertices[pointi]].labels(faces);

                    scalar cval = 0.0;
                    scalar rdistSum = 0.0;
                    forAll (ps, i)
                    {
                        scalar rdist = 1.0/mag
                        (
                            centres[centreVertices[pointi]] - points[ps[i]]
                        );
                        cval += rdist*psf[ps[i]];
                        rdistSum += rdist;
                    }

                    fField[nPoints + pointi] = float(cval/rdistSum);
                }

                fvFile.write
                (
                    (char *)fField.begin(), fField.size()*sizeof(float)
                );
            }
            else
            {
                fvFile.write
                (
                    (char *)dummyField.begin(), dummyField.size()*sizeof(float)
                );
            }
        }


        //
        // Boundary variables data
        //     1. volFields
        //     2. surfFields

        writeInt(fvFile, FV_BNDRY_VARS);

        forAll(volFieldPtrs, fieldI)
        {
            if (volFieldPtrs[fieldI] != NULL)
            {
                const volScalarField& vsf = *volFieldPtrs[fieldI];

                forAll (mesh.boundary(), patchI)
                {
                    DynamicList<label>& faceMap = patchFaceMap[patchI];

                    const scalarField& boundaryField
                    (
                        vsf.boundaryField()[patchI]
                    );

                    // Start off with dummy value.
                    floatField fField(faceMap.size(), 0.0);

                    // Fill valid faces with field values
                    forAll(boundaryField, faceI)
                    {
                        fField[faceI] = float(boundaryField[faceMap[faceI]]);
                    }

                    fvFile.write
                    (
                        (char *)fField.begin(), fField.size()*sizeof(float)
                    );
                }
            }
            else
            {
                forAll (mesh.boundary(), patchI)
                {
                    DynamicList<label>& faceMap = patchFaceMap[patchI];

                    // Start off with dummy value.
                    floatField fField(faceMap.size(), 0.0);

                    fvFile.write
                    (
                        (char *)fField.begin(), fField.size()*sizeof(float)
                    );
                }
            }
        }

        // surfFields
        forAll(surfFieldPtrs, fieldI)
        {
            if (surfFieldPtrs[fieldI] != NULL)
            {
                const surfaceScalarField& ssf = *surfFieldPtrs[fieldI];

                forAll (mesh.boundary(), patchI)
                {
                    DynamicList<label>& faceMap = patchFaceMap[patchI];

                    const scalarField& boundaryField
                    (
                        ssf.boundaryField()[patchI]
                    );

                    // Start off with dummy value.
                    floatField fField(faceMap.size(), 0.0);

                    // Fill valid faces with field values
                    forAll(boundaryField, faceI)
                    {
                        fField[faceI] = float(boundaryField[faceI]);
                    }
                    fvFile.write
                    (
                        (char *)fField.begin(), fField.size()*sizeof(float)
                    );
                }
            }
            else
            {
                forAll (mesh.boundary(), patchI)
                {
                    DynamicList<label>& faceMap = patchFaceMap[patchI];

                    // Start off with dummy value.
                    floatField fField(faceMap.size(), 0.0);

                    fvFile.write
                    (
                        (char *)fField.begin(), fField.size()*sizeof(float)
                    );
                }
            }
        }


        //
        // Cleanup volume and surface fields
        //
        forAll(volFieldPtrs, fieldI)
        {
            delete volFieldPtrs[fieldI];
        }
        forAll(surfFieldPtrs, fieldI)
        {
            delete surfFieldPtrs[fieldI];
        }




        //
        // Spray
        //
        if (hasLagrangian)
        {
            // Read/create fields:
            //     sprayScalarFieldPtrs: List of ptrs to lagrangian scalfields
            //     sprayVectorFieldPtrs:               ,,           vec  ,,
#           include "createSprayFields.H"


            // Write time header

            // Time index (FieldView: has to start from 1)
            writeInt(fvParticleFile, fieldViewTime + 1);

            // Time value
            writeFloat(fvParticleFile, Times[i].value());

            // Read particles
            Cloud<passiveParticle> parcels(mesh);

            // Num particles
            writeInt(fvParticleFile, parcels.size());

            Info<< "    Writing " << parcels.size() << " particles." << endl;


            //
            // Output data parcelwise
            //

            label parcelNo = 0;


            for
            (
                Cloud<passiveParticle>::iterator elmnt = parcels.begin();
                elmnt != parcels.end();
                ++elmnt, parcelNo++
            )
            {
                writeInt(fvParticleFile, parcelNo+1);

                writeFloat(fvParticleFile, elmnt().position().x());
                writeFloat(fvParticleFile, elmnt().position().y());
                writeFloat(fvParticleFile, elmnt().position().z());

                forAll(sprayScalarFieldPtrs, fieldI)
                {
                    if (sprayScalarFieldPtrs[fieldI] != NULL)
                    {
                        const IOField<scalar>& sprayField =
                            *sprayScalarFieldPtrs[fieldI];
                        writeFloat
                        (
                            fvParticleFile,
                            sprayField[parcelNo]
                        );
                    }
                    else
                    {
                        writeFloat(fvParticleFile, 0.0);
                    }
                }
                forAll(sprayVectorFieldPtrs, fieldI)
                {
                    if (sprayVectorFieldPtrs[fieldI] != NULL)
                    {
                        const IOField<vector>& sprayVectorField =
                            *sprayVectorFieldPtrs[fieldI];
                        const vector& val =
                            sprayVectorField[parcelNo];

                        writeFloat(fvParticleFile, val.x());
                        writeFloat(fvParticleFile, val.y());
                        writeFloat(fvParticleFile, val.z());
                    }
                    else
                    {
                        writeFloat(fvParticleFile, 0.0);
                        writeFloat(fvParticleFile, 0.0);
                        writeFloat(fvParticleFile, 0.0);
                    }
                }
            }

            // increment fieldView particle time
            fieldViewTime++;


            //
            // Cleanup spray fields
            //
            forAll(sprayScalarFieldPtrs, fieldI)
            {
                delete sprayScalarFieldPtrs[fieldI];
            }
            forAll(sprayVectorFieldPtrs, fieldI)
            {
                delete sprayVectorFieldPtrs[fieldI];
            }

        } // end of hasLagrangian
    }

    if (!hasLagrangian)
    {
        rm(fvParticleFileName);
    }

    Info << "End\n" << endl;

    return 0;
}


// ************************************************************************* //
